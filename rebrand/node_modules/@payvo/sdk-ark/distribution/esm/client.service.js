var __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Enums } from "@arkecosystem/crypto";
import { Collections, Helpers, IoC, Services } from "@payvo/sdk";
import dotify from "node-dotify";
let ClientService = class ClientService extends Services.AbstractClientService {
    async transaction(id, input) {
        const body = await this.#get(`transactions/${id}`);
        return this.dataTransferObjectService.transaction(body.data);
    }
    async transactions(query) {
        const response = this.#isLegacy() ?
            await this.#post("transactions/search", this.#createSearchParams(query)) :
            await this.#get("transactions", this.#createSearchParams(query));
        return this.dataTransferObjectService.transactions(response.data, this.#createMetaPagination(response));
    }
    async wallet(id) {
        const body = await this.#get(`wallets/${id.value}`);
        return this.dataTransferObjectService.wallet(body.data);
    }
    async wallets(query) {
        const response = this.#isLegacy() ?
            await this.#post("wallets/search", this.#createSearchParams(query)) :
            await this.#get("wallets", this.#createSearchParams(query));
        return new Collections.WalletDataCollection(response.data.map((wallet) => this.dataTransferObjectService.wallet(wallet)), this.#createMetaPagination(response));
    }
    async delegate(id) {
        const body = await this.#get(`delegates/${id}`);
        return this.dataTransferObjectService.wallet(body.data);
    }
    async delegates(query) {
        const body = await this.#get("delegates", this.#createSearchParams(query || {}));
        return new Collections.WalletDataCollection(body.data.map((wallet) => this.dataTransferObjectService.wallet(wallet)), this.#createMetaPagination(body));
    }
    async votes(id) {
        const { data } = await this.#get(`wallets/${id}`);
        const vote = data.vote || data.attributes ? .vote;
        const hasVoted = vote !== undefined;
        return {
            used: hasVoted ? 1 : 0,
            available: hasVoted ? 0 : 1,
            votes: hasVoted ? [{
                id: vote,
                amount: 0,
            }, ] : [],
        };
    }
    async voters(id, query) {
        const body = await this.#get(`delegates/${id}/voters`, this.#createSearchParams(query || {}));
        return new Collections.WalletDataCollection(body.data.map((wallet) => this.dataTransferObjectService.wallet(wallet)), this.#createMetaPagination(body));
    }
    async broadcast(transactions) {
        let response;
        try {
            response = await this.#post("transactions", {
                body: {
                    transactions: transactions.map((transaction) => transaction.toBroadcast()),
                },
            });
        } catch (error) {
            response = error.response.json();
        }
        const { data, errors } = response;
        const result = {
            accepted: [],
            rejected: [],
            errors: {},
        };
        if (Array.isArray(data.accept)) {
            result.accepted = data.accept;
        }
        if (Array.isArray(data.invalid)) {
            result.rejected = data.invalid;
        }
        if (errors) {
            const responseErrors = Object.entries(errors);
            for (const [key, value] of responseErrors) {
                if (Array.isArray(value)) {
                    result.errors[key] = value[0].message;
                } else {
                    result.errors[key] = value.message;
                }
            }
        }
        return result;
    }
    async# get(path, query) {
        return (await this.httpClient.get(`${Helpers.randomHostFromConfig(this.configRepository)}/${path}`, query ? .searchParams)).json();
    }
    async# post(path, { body, searchParams }) {
        return (await this.httpClient.post(`${Helpers.randomHostFromConfig(this.configRepository)}/${path}`, body, searchParams || undefined)).json();
    }#
    createMetaPagination(body) {
        const getPage = (url) => {
            const match = RegExp(/page=(\d+)/).exec(url);
            return match ? match[1] || undefined : undefined;
        };
        return {
            prev: getPage(body.meta.previous) || undefined,
            self: getPage(body.meta.self) || undefined,
            next: getPage(body.meta.next) || undefined,
            last: getPage(body.meta.last) || undefined,
        };
    }#
    createSearchParams(body) {
            if (Object.keys(body).length <= 0) {
                return { body: null, searchParams: null };
            }
            const result = {
                body,
                searchParams: {},
            };
            const mappings = {
                cursor: "page",
                limit: "limit",
                orderBy: "orderBy",
                memo: "vendorField",
            };
            if (!this.#isLegacy()) {
                Object.assign(mappings, {
                    address: "address",
                    recipientId: "recipientId",
                    senderId: "senderId",
                    senderPublicKey: "senderPublicKey",
                });
            }
            for (const [alias, original] of Object.entries(mappings)) {
                if (body[alias]) {
                    result.searchParams[original] = body[alias];
                    delete result.body[alias];
                }
            }
            if (body.identifiers) {
                const identifiers = body.identifiers;
                if (this.#isLegacy()) {
                    result.body.addresses = identifiers.map(({ value }) => value);
                } else {
                    result.searchParams.address = identifiers.map(({ value }) => value).join(",");
                }
                // @ts-ignore
                delete body.identifiers;
            }
            // @ts-ignore
            if (body.type) {
                const { type, typeGroup } = {
                    delegateRegistration: {
                        type: Enums.TransactionType.DelegateRegistration,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    delegateResignation: {
                        type: Enums.TransactionType.DelegateResignation,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    htlcClaim: {
                        type: Enums.TransactionType.HtlcClaim,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    htlcLock: {
                        type: Enums.TransactionType.HtlcLock,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    htlcRefund: {
                        type: Enums.TransactionType.HtlcRefund,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    ipfs: {
                        type: Enums.TransactionType.Ipfs,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    multiPayment: {
                        type: Enums.TransactionType.MultiPayment,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    multiSignature: {
                        type: Enums.TransactionType.MultiSignature,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    secondSignature: {
                        type: Enums.TransactionType.SecondSignature,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    transfer: {
                        type: Enums.TransactionType.Transfer,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    vote: {
                        type: Enums.TransactionType.Vote,
                        typeGroup: Enums.TransactionTypeGroup.Core,
                    },
                    magistrate: {
                        typeGroup: 2,
                    },
                    // @ts-ignore
                }[body.type];
                if (type !== undefined) {
                    if (this.#isLegacy()) {
                        result.body.type = type;
                    } else {
                        result.searchParams.type = type;
                    }
                }
                if (typeGroup !== undefined) {
                    if (this.#isLegacy()) {
                        result.body.typeGroup = typeGroup;
                    } else {
                        result.searchParams.typeGroup = typeGroup;
                    }
                }
                if (!this.#isLegacy()) {
                    // @ts-ignore
                    delete body.type;
                }
            }
            if (!this.#isLegacy()) {
                result.searchParams = dotify({...result.searchParams, ...result.body });
                result.body = null;
            }
            return result;
        }#
        // legacy assets are for blockchain 2.x
    isLegacy() {
        return ["bind", "bpl", "xqr"].some((coin) => this.configRepository.get("network.id").startsWith(coin));
    }
};
ClientService = __decorate([
    IoC.injectable()
], ClientService);
export { ClientService };
//# sourceMappingURL=client.service.js.map